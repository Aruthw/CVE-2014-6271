--- bash-4.3-patched/builtins/common.h	2018-07-18 12:57:29.656000999 +0000
+++ bash-4.3/builtins/common.h	2013-07-08 20:54:47.000000000 +0000
@@ -33,8 +33,6 @@
 #define SEVAL_RESETLINE	0x010
 #define SEVAL_PARSEONLY	0x020
 #define SEVAL_NOLONGJMP 0x040
-#define SEVAL_FUNCDEF	0x080		/* only allow function definitions */
-#define SEVAL_ONECMD	0x100		/* only allow a single command */
 
 /* Flags for describe_command, shared between type.def and command.def */
 #define CDESC_ALL		0x001	/* type -a */
--- bash-4.3-patched/variables.c	2018-07-18 12:57:29.664000999 +0000
+++ bash-4.3/variables.c	2018-07-18 13:15:52.284000999 +0000
@@ -2191,7 +2191,10 @@
   /* local foo; local foo;  is a no-op. */
   old_var = find_variable (name);
   if (old_var && local_p (old_var) && old_var->context == variable_context)
-    return (old_var);
+    {
+      VUNSETATTR (old_var, att_invisible);	/* XXX */
+      return (old_var);
+    }
 
   was_tmpvar = old_var && tempvar_p (old_var);
   /* If we're making a local variable in a shell function, the temporary env
--- bash-4.3-patched/subst.c	2018-07-18 12:57:29.664000999 +0000
+++ bash-4.3/subst.c	2018-07-18 13:15:52.288000999 +0000
@@ -1192,18 +1192,12 @@
    Start extracting at (SINDEX) as if we had just seen "<(".
    Make (SINDEX) get the position of the matching ")". */ /*))*/
 char *
-extract_process_subst (string, starter, sindex, xflags)
+extract_process_subst (string, starter, sindex)
      char *string;
      char *starter;
      int *sindex;
-     int xflags;
 {
-#if 0
   return (extract_delimited_string (string, sindex, starter, "(", ")", SX_COMMAND));
-#else
-  xflags |= (no_longjmp_on_fatal_error ? SX_NOLONGJMP : 0);
-  return (xparse_dolparen (string, string+*sindex, sindex, xflags));
-#endif
 }
 #endif /* PROCESS_SUBSTITUTION */
 
@@ -1791,7 +1785,7 @@
 	  si = i + 2;
 	  if (string[si] == '\0')
 	    CQ_RETURN(si);
-	  temp = extract_process_subst (string, (c == '<') ? "<(" : ">(", &si, 0);
+	  temp = extract_process_subst (string, (c == '<') ? "<(" : ">(", &si);
 	  free (temp);		/* no SX_ALLOC here */
 	  i = si;
 	  if (string[i] == '\0')
@@ -3254,10 +3248,8 @@
   if (w->word == 0 || w->word[0] == '\0')
     return ((char *)NULL);
 
-  expand_no_split_dollar_star = 1;
   w->flags |= W_NOSPLIT2;
   l = call_expand_word_internal (w, 0, 0, (int *)0, (int *)0);
-  expand_no_split_dollar_star = 0;
   if (l)
     {
       if (special == 0)			/* LHS */
@@ -7374,13 +7366,7 @@
     }
 
   if (want_indir)
-    {
-      tdesc = parameter_brace_expand_indir (name + 1, var_is_special, quoted, quoted_dollar_atp, contains_dollar_at);
-      /* Turn off the W_ARRAYIND flag because there is no way for this function
-	 to return the index we're supposed to be using. */
-      if (tdesc && tdesc->flags)
-	tdesc->flags &= ~W_ARRAYIND;
-    }
+    tdesc = parameter_brace_expand_indir (name + 1, var_is_special, quoted, quoted_dollar_atp, contains_dollar_at);
   else
     tdesc = parameter_brace_expand_word (name, var_is_special, quoted, PF_IGNUNBOUND|(pflags&(PF_NOSPLIT2|PF_ASSIGNRHS)), &ind);
 
@@ -7861,10 +7847,6 @@
 	 We also want to make sure that splitting is done no matter what --
 	 according to POSIX.2, this expands to a list of the positional
 	 parameters no matter what IFS is set to. */
-      /* XXX - what to do when in a context where word splitting is not
-	 performed? Even when IFS is not the default, posix seems to imply
-	 that we behave like unquoted $* ?  Maybe we should use PF_NOSPLIT2
-	 here. */
       temp = string_list_dollar_at (list, (pflags & PF_ASSIGNRHS) ? (quoted|Q_DOUBLE_QUOTES) : quoted);
 
       tflag |= W_DOLLARAT;
@@ -8263,7 +8245,7 @@
 	    else
 	      t_index = sindex + 1; /* skip past both '<' and LPAREN */
 
-	    temp1 = extract_process_subst (string, (c == '<') ? "<(" : ">(", &t_index, 0); /*))*/
+	    temp1 = extract_process_subst (string, (c == '<') ? "<(" : ">(", &t_index); /*))*/
 	    sindex = t_index;
 
 	    /* If the process substitution specification is `<()', we want to
@@ -8836,7 +8818,6 @@
   else
     {
       char *ifs_chars;
-      char *tstring;
 
       ifs_chars = (quoted_dollar_at || has_dollar_at) ? ifs_value : (char *)NULL;
 
@@ -8851,36 +8832,11 @@
 	 regardless of what else has happened to IFS since the expansion. */
       if (split_on_spaces)
 	list = list_string (istring, " ", 1);	/* XXX quoted == 1? */
-      /* If we have $@ (has_dollar_at != 0) and we are in a context where we
-	 don't want to split the result (W_NOSPLIT2), and we are not quoted,
-	 we have already separated the arguments with the first character of
-	 $IFS.  In this case, we want to return a list with a single word
-	 with the separator possibly replaced with a space (it's what other
-	 shells seem to do).
-	 quoted_dollar_at is internal to this function and is set if we are
-	 passed an argument that is unquoted (quoted == 0) but we encounter a
-	 double-quoted $@ while expanding it. */
-      else if (has_dollar_at && quoted_dollar_at == 0 && ifs_chars && quoted == 0 && (word->flags & W_NOSPLIT2))
-	{
-	  /* Only split and rejoin if we have to */
-	  if (*ifs_chars && *ifs_chars != ' ')
-	    {
-	      list = list_string (istring, *ifs_chars ? ifs_chars : " ", 1);
-	      tstring = string_list (list);
-	    }
-	  else
-	    tstring = istring;
-	  tword = make_bare_word (tstring);
-	  if (tstring != istring)
-	    free (tstring);
-	  goto set_word_flags;
-	}
       else if (has_dollar_at && ifs_chars)
 	list = list_string (istring, *ifs_chars ? ifs_chars : " ", 1);
       else
 	{
 	  tword = make_bare_word (istring);
-set_word_flags:
 	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || (quoted_state == WHOLLY_QUOTED))
 	    tword->flags |= W_QUOTED;
 	  if (word->flags & W_ASSIGNMENT)
--- bash-4.3-patched/patchlevel.h	2018-07-18 12:57:29.668000999 +0000
+++ bash-4.3/patchlevel.h	2012-12-29 15:47:57.000000000 +0000
@@ -25,6 +25,6 @@
    regexp `^#define[ 	]*PATCHLEVEL', since that's what support/mkversion.sh
    looks for to find the patch level (for the sccs version string). */
 
-#define PATCHLEVEL 25
+#define PATCHLEVEL 0
 
 #endif /* _PATCHLEVEL_H_ */
